# spidemo
A demo about spi
## 1.Java SPI
Java SPI,全称Java ervice Provider Interface(Java服务提供者接口),是一种动态加载机制,
一般是面对厂商或者开发插件之类拓展功能提供的。
在做系统设计时，我们往往会把一些具体服务做出一些抽象接口，在接口中定义基本功能，具体的实现，
交由实现者去提供（Service Provider，服务提供者），从而提高拓展性，降低耦合性，而接口往往有很多不同的实现方案，
在面向对象的设计里，一般推荐模块之间基于接口编程，而不是对实现类进行硬编码；
一旦涉及了具体的实现类，就违反了可插拔原则，当我们需要替换一种实现，或者拓展一种新的是实现时，
就需要修改代码。为了实现在模块装配的时候可以动态的指明实现者（Service Provider，服务提供者）而不是提前硬编码，
我们就需要一种服务的发现机制，
这样，在我们替换或者拓展新的实现时，不需要直接去改动代码，只需要改下配置文件即可，
Java SPI就提供了一个这样的机制，它可以为某个接口寻找发现具体的服务实现。

## 2.使用场景
概括来讲，当我们有拓展，或者动态替换，解耦等需求时，其实就可以想起SPI的机制，这种思想，其实也是一种解耦的思想。
比较常见的例子有：
- 数据库驱动加载接口实现类的加载
- JDBC加载不同类型数据库的驱动
- 日志门面接口实现类加载
- SLF4J加载不同提供商的日志实现类
......
此外，在一些开源项目中，也经常见到，如dubbo，hmily等。

## 3.SPI约定
如果要使用SPI，需要遵守如下约定：

1、当服务提供者提供了接口的一种具体实现后，在项目的META-INF/services目录（如果没有，自己创建一个目录）下，
创建一个以“接口全限定名”为文件名的文件，文件的内容是实现了类的权限定名；

2、主程序通过java.util.ServiceLoder动态装载服务接口的实现模块，
它通过扫描META-INF/services目录下的配置文件找到服务接口的实现类的全限定名，然后把服务实现类加载到JVM；

3、服务接口的实现类，需要有一个无参构造函数。

## 4.实例场景
假设一种场景，借此场景使用spi来解决问题。
假设：在项目中，有一个语言处理器，这个语言处理器有一个翻译语言的基础功能待实现，开发者根据自己需要，
来对语言处理器做具体实现。

如果有多种实现可选择，那么希望可以通过配置文件来配置语言环境，然后对应的语言处理器就可以生效，
不需要硬编码。
